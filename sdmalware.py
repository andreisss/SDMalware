import argparse
import math
from math import log2
import pefile
import hashlib
import datetime
import subprocess
import shlex
import time
import datetime


def get_machine_type(path):
    try:
        pe = pefile.PE(path)
        if pe.FILE_HEADER.Machine == 0x14c:
            return "File : x86"
        elif pe.FILE_HEADER.Machine == 0x8664:
            return "File : x64"
        else:
            return "File : unknown"
    except Exception as e:
        print(f"Error: {e}")
        return None

def get_image_base(path):
    pe = pefile.PE(path)
    return hex(pe.OPTIONAL_HEADER.ImageBase)
    
def list_resource_directories(path):
    pe = pefile.PE(path)

    if not hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
        print("Resource directory: None")
        return

    resource_dir = pe.DIRECTORY_ENTRY_RESOURCE
    print(resource_dir)

    for resource_type in resource_dir.entries:
        print(resource_type)
        if resource_type.name is not None:
            print("\tResource type: {}".format(resource_type.name))
        else:
            print("\tResource type: {}".format(pefile.RESOURCE_TYPE.get(resource_type.struct.Id)))
        
        if hasattr(resource_type, 'directory'):
            for resource_id in resource_type.directory.entries:
                if hasattr(resource_id, 'directory'):
                    for resource_lang in resource_id.directory.entries:
                        print("\t\tResource language: {}".format(resource_lang.data.lang))
                        print("\t\tResource sublanguage: {}".format(resource_lang.data.sublang))
                        print("\t\tResource RVA: {}".format(resource_lang.data.struct.OffsetToData))
                        print("\t\tResource size: {}".format(resource_lang.data.struct.Size))
        else:
            print("\tNo resources found.")

def has_tls_directory(path):
    try:
        pe = pefile.PE(path)
        if hasattr(pe, 'DIRECTORY_ENTRY_TLS'):
            return True
        return False
    except Exception as e:
        print(f"Error: {e}")
        return False

    
def list_dlls(path):
    dll_dict = {}
    pe = pefile.PE(path)

    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        dll_name = entry.dll.decode('utf-8')
        dll_dict[dll_name] = []
        for lib in entry.imports:
            if not lib.name:
                continue
            else:
                dll_dict[dll_name].append(lib.name.decode('utf-8'))

    return dll_dict


def shannon_entropy(data):
    # 256 different possible values
    possible = dict(((chr(x), 0) for x in range(0, 256)))

    for byte in data:
        possible[chr(byte)] += 1

    data_len = len(data)
    entropy = 0.0

    # compute
    for i in possible:
        if possible[i] == 0:
            continue

        p = float(possible[i] / data_len)
        entropy -= p * math.log(p, 2)
    # check entropy and format output
    if entropy > 7:
        return f"\033[31m{entropy:.2f}\033[0m"
    else:
        return f"{entropy:.2f}"


def sections_entropy(path):
    pe = pefile.PE(path)
    section_comments = {
        ".text": "Contains the executable code",
        ".rdata": "Holds read-only data that is globally accessible within the program",
        ".data": "Stores global data accessed throughout the program",
        ".idata": "Sometimes present and stores the import function information; if this section is not present, the import function information is stored in the .rdata section",
        ".edata": "Sometimes present and stores the export function information; if this section is not present, the export function information is stored in the .rdata section",
        ".pdata": "Present only in 64-bit executables and stores exception-handling information",
        ".rsrc": "Stores resources needed by the executable",
        ".reloc": "Contains information for relocation of library files",
    }

    for section in pe.sections:
        section_name = section.Name.decode('utf-8').rstrip('\x00')
        print(section_name)
        if section_name in section_comments:
            print("\t{}".format(section_comments[section_name]))
        print("\tvirtual address: {}".format(hex(section.VirtualAddress)))
        print("\tvirtual size: {}".format(hex(section.Misc_VirtualSize)))
        print("\traw size: {}".format(hex(section.SizeOfRawData)))
        print("\tentropy: " + str(shannon_entropy(section.get_data())))

        # Calculate the hash for the section data
        section_data = section.get_data()
        section_hash = hashlib.sha256(section_data).hexdigest()
        print("\tSHA256 hash: {}".format(section_hash))

    dll_dict = list_dlls(path)
    print("\n\n")
    print("\033[32mDLLs imported by the PE file:\033[0m")
    for dll_name, dll_hash in dll_dict.items():
        print("\033[32m-----------------------------\033[0m")
        print("{}\t{}".format(dll_name, dll_hash))



def get_timestamp(path):
    pe = pefile.PE(path)
    timestamp = pe.FILE_HEADER.TimeDateStamp
    return timestamp

        
def capa_analysis(target_file):
    # run capa command and capture output
    capa_output = subprocess.run(["/root/capa", target_file], capture_output=True, text=True)
    print("\033[32m-----------------------------\033[0m")
    # print capa output to console
    print(capa_output.stdout)
  

def run_speakeasy(target_file, output_file):
    """
    Run speakeasy with the specified target file and write the output to the specified file.
    """
    cmd = f"/usr/bin/speakeasy --target {shlex.quote(target_file)} -o {shlex.quote(output_file)}"
    with open(output_file, "w") as f:
        process = subprocess.Popen(cmd, stdout=f, stderr=subprocess.PIPE, shell=True)
        print("\033[32m-----------------------------\033[0m")
        print("Speakeasy Output created  :" , output_file)
        print("\033[32m-----------------------------\033[0m")
        _, error = process.communicate()
        if process.returncode != 0:
            print("Error running speakeasy:", error.decode())


def clamscan_scan(file_path):
    try:
        result = subprocess.run(['clamscan', '-i', file_path], capture_output=True, text=True)
        if " FOUND" in result.stdout:
            print(f"{file_path} - Malware detected: {result.stdout}")
        else:
            print(f"{file_path} - No malware detected")
    except Exception as e:
        print(f"Error while scanning {file_path}: {e}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-f', '--file', required=True, help="target file")
    args = parser.parse_args()
    target_file = args.file
    timestamp = get_timestamp(target_file)
    machine = get_machine_type(target_file)
    imagebase = get_image_base(target_file)
    utc_time = datetime.datetime.utcfromtimestamp(timestamp)
    print("\033[32m-----------------------------\033[0m")
    print(f"Time Date Stamp Program: {utc_time}")
    print(f"Machine: {machine}")
    print(f"Imagebase : {imagebase}")
    print("\033[32m-----------------------------\033[0m")
    print("\033[32m Resources \033[0m")
    resources = list_resource_directories(target_file)
    tls = has_tls_directory(target_file)
    try:
        print("\033[32m Sections \033[0m")
        sections_entropy(target_file)
    except Exception as e:
        print(f"Error in sections_entropy: {e}")
    try:
        run_speakeasy(target_file, "speakeasy_out.txt")
    except Exception as e:
        print(f"Error in run_speakeasy: {e}")
    try:
        capa_analysis(target_file)
    except Exception as e:
        print(f"Error in capa_analysis: {e}")
    try:
        print("\033[32m ClamAV Scan Result \033[0m")
        clamscan_scan(target_file)
    except Exception as e:
        print(f"Error in pyclamd_scan: {e}")
